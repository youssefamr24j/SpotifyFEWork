{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar net = require('net');\n\nvar url = require('url');\n\nvar http = require('http');\n\nvar assert = require('assert');\n\nvar debug = require('debug')('proxy'); // log levels\n\n\ndebug.request = require('debug')('proxy ← ← ←');\ndebug.response = require('debug')('proxy → → →');\ndebug.proxyRequest = require('debug')('proxy ↑ ↑ ↑');\ndebug.proxyResponse = require('debug')('proxy ↓ ↓ ↓'); // hostname\n\nvar hostname = require('os').hostname(); // proxy server version\n\n\nvar version = require('./package.json').version;\n/**\n * Module exports.\n */\n\n\nmodule.exports = setup;\n/**\n * Sets up an `http.Server` or `https.Server` instance with the necessary\n * \"request\" and \"connect\" event listeners in order to make the server act as an\n * HTTP proxy.\n *\n * @param {http.Server|https.Server} server\n * @param {Object} options\n * @api public\n */\n\nfunction setup(server, options) {\n  if (!server) server = http.createServer();\n  server.on('request', onrequest);\n  server.on('connect', onconnect);\n  return server;\n}\n/**\n * 13.5.1 End-to-end and Hop-by-hop Headers\n *\n * Hop-by-hop headers must be removed by the proxy before passing it on to the\n * next endpoint. Per-request basis hop-by-hop headers MUST be listed in a\n * Connection header, (section 14.10) to be introduced into HTTP/1.1 (or later).\n */\n\n\nvar hopByHopHeaders = ['Connection', 'Keep-Alive', 'Proxy-Authenticate', 'Proxy-Authorization', 'TE', 'Trailers', 'Transfer-Encoding', 'Upgrade']; // create a case-insensitive RegExp to match \"hop by hop\" headers\n\nvar isHopByHop = new RegExp('^(' + hopByHopHeaders.join('|') + ')$', 'i');\n/**\n * Iterator function for the request/response's \"headers\".\n * Invokes `fn` for \"each\" header entry in the request.\n *\n * @api private\n */\n\nfunction eachHeader(obj, fn) {\n  if (Array.isArray(obj.rawHeaders)) {\n    // ideal scenario... >= node v0.11.x\n    // every even entry is a \"key\", every odd entry is a \"value\"\n    var key = null;\n    obj.rawHeaders.forEach(function (v) {\n      if (key === null) {\n        key = v;\n      } else {\n        fn(key, v);\n        key = null;\n      }\n    });\n  } else {\n    // otherwise we can *only* proxy the header names as lowercase'd\n    var headers = obj.headers;\n    if (!headers) return;\n    Object.keys(headers).forEach(function (key) {\n      var value = headers[key];\n\n      if (Array.isArray(value)) {\n        // set-cookie\n        value.forEach(function (val) {\n          fn(key, val);\n        });\n      } else {\n        fn(key, value);\n      }\n    });\n  }\n}\n/**\n * HTTP GET/POST/DELETE/PUT, etc. proxy requests.\n */\n\n\nfunction onrequest(req, res) {\n  debug.request('%s %s HTTP/%s ', req.method, req.url, req.httpVersion);\n  var server = this;\n  var socket = req.socket; // pause the socket during authentication so no data is lost\n\n  socket.pause();\n  authenticate(server, req, function (err, auth) {\n    socket.resume();\n\n    if (err) {\n      // an error occured during login!\n      res.writeHead(500);\n      res.end((err.stack || err.message || err) + '\\n');\n      return;\n    }\n\n    if (!auth) return requestAuthorization(req, res);\n    var parsed = url.parse(req.url); // proxy the request HTTP method\n\n    parsed.method = req.method; // setup outbound proxy request HTTP headers\n\n    var headers = {};\n    var hasXForwardedFor = false;\n    var hasVia = false;\n    var via = '1.1 ' + hostname + ' (proxy/' + version + ')';\n    parsed.headers = headers;\n    eachHeader(req, function (key, value) {\n      debug.request('Request Header: \"%s: %s\"', key, value);\n      var keyLower = key.toLowerCase();\n\n      if (!hasXForwardedFor && 'x-forwarded-for' === keyLower) {\n        // append to existing \"X-Forwarded-For\" header\n        // http://en.wikipedia.org/wiki/X-Forwarded-For\n        hasXForwardedFor = true;\n        value += ', ' + socket.remoteAddress;\n        debug.proxyRequest('appending to existing \"%s\" header: \"%s\"', key, value);\n      }\n\n      if (!hasVia && 'via' === keyLower) {\n        // append to existing \"Via\" header\n        hasVia = true;\n        value += ', ' + via;\n        debug.proxyRequest('appending to existing \"%s\" header: \"%s\"', key, value);\n      }\n\n      if (isHopByHop.test(key)) {\n        debug.proxyRequest('ignoring hop-by-hop header \"%s\"', key);\n      } else {\n        var v = headers[key];\n\n        if (Array.isArray(v)) {\n          v.push(value);\n        } else if (null != v) {\n          headers[key] = [v, value];\n        } else {\n          headers[key] = value;\n        }\n      }\n    }); // add \"X-Forwarded-For\" header if it's still not here by now\n    // http://en.wikipedia.org/wiki/X-Forwarded-For\n\n    if (!hasXForwardedFor) {\n      headers['X-Forwarded-For'] = socket.remoteAddress;\n      debug.proxyRequest('adding new \"X-Forwarded-For\" header: \"%s\"', headers['X-Forwarded-For']);\n    } // add \"Via\" header if still not set by now\n\n\n    if (!hasVia) {\n      headers.Via = via;\n      debug.proxyRequest('adding new \"Via\" header: \"%s\"', headers.Via);\n    } // custom `http.Agent` support, set `server.agent`\n\n\n    var agent = server.agent;\n\n    if (null != agent) {\n      debug.proxyRequest('setting custom `http.Agent` option for proxy request: %s', agent);\n      parsed.agent = agent;\n      agent = null;\n    }\n\n    if (null == parsed.port) {\n      // default the port number if not specified, for >= node v0.11.6...\n      // https://github.com/joyent/node/issues/6199\n      parsed.port = 80;\n    }\n\n    if ('http:' != parsed.protocol) {\n      // only \"http://\" is supported, \"https://\" should use CONNECT method\n      res.writeHead(400);\n      res.end('Only \"http:\" protocol prefix is supported\\n');\n      return;\n    }\n\n    if (server.localAddress) {\n      parsed.localAddress = server.localAddress;\n    }\n\n    var gotResponse = false;\n    var proxyReq = http.request(parsed);\n    debug.proxyRequest('%s %s HTTP/1.1 ', proxyReq.method, proxyReq.path);\n    proxyReq.on('response', function (proxyRes) {\n      debug.proxyResponse('HTTP/1.1 %s', proxyRes.statusCode);\n      gotResponse = true;\n      var headers = {};\n      eachHeader(proxyRes, function (key, value) {\n        debug.proxyResponse('Proxy Response Header: \"%s: %s\"', key, value);\n\n        if (isHopByHop.test(key)) {\n          debug.response('ignoring hop-by-hop header \"%s\"', key);\n        } else {\n          var v = headers[key];\n\n          if (Array.isArray(v)) {\n            v.push(value);\n          } else if (null != v) {\n            headers[key] = [v, value];\n          } else {\n            headers[key] = value;\n          }\n        }\n      });\n      debug.response('HTTP/1.1 %s', proxyRes.statusCode);\n      res.writeHead(proxyRes.statusCode, headers);\n      proxyRes.pipe(res);\n      res.on('finish', onfinish);\n    });\n    proxyReq.on('error', function (err) {\n      debug.proxyResponse('proxy HTTP request \"error\" event\\n%s', err.stack || err);\n      cleanup();\n\n      if (gotResponse) {\n        debug.response('already sent a response, just destroying the socket...');\n        socket.destroy();\n      } else if ('ENOTFOUND' == err.code) {\n        debug.response('HTTP/1.1 404 Not Found');\n        res.writeHead(404);\n        res.end();\n      } else {\n        debug.response('HTTP/1.1 500 Internal Server Error');\n        res.writeHead(500);\n        res.end();\n      }\n    }); // if the client closes the connection prematurely,\n    // then close the upstream socket\n\n    function onclose() {\n      debug.request('client socket \"close\" event, aborting HTTP request to \"%s\"', req.url);\n      proxyReq.abort();\n      cleanup();\n    }\n\n    socket.on('close', onclose);\n\n    function onfinish() {\n      debug.response('\"finish\" event');\n      cleanup();\n    }\n\n    function cleanup() {\n      debug.response('cleanup');\n      socket.removeListener('close', onclose);\n      res.removeListener('finish', onfinish);\n    }\n\n    req.pipe(proxyReq);\n  });\n}\n/**\n * HTTP CONNECT proxy requests.\n */\n\n\nfunction onconnect(req, socket, head) {\n  debug.request('%s %s HTTP/%s ', req.method, req.url, req.httpVersion);\n  assert(!head || 0 == head.length, '\"head\" should be empty for proxy requests');\n  var res;\n  var target;\n  var gotResponse = false; // define request socket event listeners\n\n  socket.on('close', function onclientclose() {\n    debug.request('HTTP request %s socket \"close\" event', req.url);\n  });\n  socket.on('end', function onclientend() {\n    debug.request('HTTP request %s socket \"end\" event', req.url);\n  });\n  socket.on('error', function onclienterror(err) {\n    debug.request('HTTP request %s socket \"error\" event:\\n%s', req.url, err.stack || err);\n  }); // define target socket event listeners\n\n  function ontargetclose() {\n    debug.proxyResponse('proxy target %s \"close\" event', req.url);\n    socket.destroy();\n  }\n\n  function ontargetend() {\n    debug.proxyResponse('proxy target %s \"end\" event', req.url);\n  }\n\n  function ontargeterror(err) {\n    debug.proxyResponse('proxy target %s \"error\" event:\\n%s', req.url, err.stack || err);\n\n    if (gotResponse) {\n      debug.response('already sent a response, just destroying the socket...');\n      socket.destroy();\n    } else if ('ENOTFOUND' == err.code) {\n      debug.response('HTTP/1.1 404 Not Found');\n      res.writeHead(404);\n      res.end();\n    } else {\n      debug.response('HTTP/1.1 500 Internal Server Error');\n      res.writeHead(500);\n      res.end();\n    }\n  }\n\n  function ontargetconnect() {\n    debug.proxyResponse('proxy target %s \"connect\" event', req.url);\n    debug.response('HTTP/1.1 200 Connection established');\n    gotResponse = true;\n    res.removeListener('finish', onfinish);\n    res.writeHead(200, 'Connection established');\n    res.flushHeaders(); // relinquish control of the `socket` from the ServerResponse instance\n\n    res.detachSocket(socket); // nullify the ServerResponse object, so that it can be cleaned\n    // up before this socket proxying is completed\n\n    res = null;\n    socket.pipe(target);\n    target.pipe(socket);\n  } // create the `res` instance for this request since Node.js\n  // doesn't provide us with one :(\n  // XXX: this is undocumented API, so it will break some day (ノಠ益ಠ)ノ彡┻━┻\n\n\n  res = new http.ServerResponse(req);\n  res.shouldKeepAlive = false;\n  res.chunkedEncoding = false;\n  res.useChunkedEncodingByDefault = false;\n  res.assignSocket(socket); // called for the ServerResponse's \"finish\" event\n  // XXX: normally, node's \"http\" module has a \"finish\" event listener that would\n  // take care of closing the socket once the HTTP response has completed, but\n  // since we're making this ServerResponse instance manually, that event handler\n  // never gets hooked up, so we must manually close the socket...\n\n  function onfinish() {\n    debug.response('response \"finish\" event');\n    res.detachSocket(socket);\n    socket.end();\n  }\n\n  res.once('finish', onfinish); // pause the socket during authentication so no data is lost\n\n  socket.pause();\n  authenticate(this, req, function (err, auth) {\n    socket.resume();\n\n    if (err) {\n      // an error occured during login!\n      res.writeHead(500);\n      res.end((err.stack || err.message || err) + '\\n');\n      return;\n    }\n\n    if (!auth) return requestAuthorization(req, res);\n    var parts = req.url.split(':');\n    var host = parts[0];\n    var port = +parts[1];\n    var opts = {\n      host: host,\n      port: port\n    };\n    debug.proxyRequest('connecting to proxy target %j', opts);\n    target = net.connect(opts);\n    target.on('connect', ontargetconnect);\n    target.on('close', ontargetclose);\n    target.on('error', ontargeterror);\n    target.on('end', ontargetend);\n  });\n}\n/**\n * Checks `Proxy-Authorization` request headers. Same logic applied to CONNECT\n * requests as well as regular HTTP requests.\n *\n * @param {http.Server} server\n * @param {http.ServerRequest} req\n * @param {Function} fn callback function\n * @api private\n */\n\n\nfunction authenticate(server, req, fn) {\n  var hasAuthenticate = 'function' == typeof server.authenticate;\n\n  if (hasAuthenticate) {\n    debug.request('authenticating request \"%s %s\"', req.method, req.url);\n    server.authenticate(req, fn);\n  } else {\n    // no `server.authenticate()` function, so just allow the request\n    fn(null, true);\n  }\n}\n/**\n * Sends a \"407 Proxy Authentication Required\" HTTP response to the `socket`.\n *\n * @api private\n */\n\n\nfunction requestAuthorization(req, res) {\n  // request Basic proxy authorization\n  debug.response('requesting proxy authorization for \"%s %s\"', req.method, req.url); // TODO: make \"realm\" and \"type\" (Basic) be configurable...\n\n  var realm = 'proxy';\n  var headers = {\n    'Proxy-Authenticate': 'Basic realm=\"' + realm + '\"'\n  };\n  res.writeHead(407, headers);\n  res.end();\n}","map":{"version":3,"sources":["/home/youssef/Desktop/Spotify_FE/node_modules/proxy/proxy.js"],"names":["net","require","url","http","assert","debug","request","response","proxyRequest","proxyResponse","hostname","version","module","exports","setup","server","options","createServer","on","onrequest","onconnect","hopByHopHeaders","isHopByHop","RegExp","join","eachHeader","obj","fn","Array","isArray","rawHeaders","key","forEach","v","headers","Object","keys","value","val","req","res","method","httpVersion","socket","pause","authenticate","err","auth","resume","writeHead","end","stack","message","requestAuthorization","parsed","parse","hasXForwardedFor","hasVia","via","keyLower","toLowerCase","remoteAddress","test","push","Via","agent","port","protocol","localAddress","gotResponse","proxyReq","path","proxyRes","statusCode","pipe","onfinish","cleanup","destroy","code","onclose","abort","removeListener","head","length","target","onclientclose","onclientend","onclienterror","ontargetclose","ontargetend","ontargeterror","ontargetconnect","flushHeaders","detachSocket","ServerResponse","shouldKeepAlive","chunkedEncoding","useChunkedEncodingByDefault","assignSocket","once","parts","split","host","opts","connect","hasAuthenticate","realm"],"mappings":"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","sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar net = require('net');\nvar url = require('url');\nvar http = require('http');\nvar assert = require('assert');\nvar debug = require('debug')('proxy');\n\n// log levels\ndebug.request = require('debug')('proxy ← ← ←');\ndebug.response = require('debug')('proxy → → →');\ndebug.proxyRequest = require('debug')('proxy ↑ ↑ ↑');\ndebug.proxyResponse = require('debug')('proxy ↓ ↓ ↓');\n\n// hostname\nvar hostname = require('os').hostname();\n\n// proxy server version\nvar version  = require('./package.json').version;\n\n/**\n * Module exports.\n */\n\nmodule.exports = setup;\n\n/**\n * Sets up an `http.Server` or `https.Server` instance with the necessary\n * \"request\" and \"connect\" event listeners in order to make the server act as an\n * HTTP proxy.\n *\n * @param {http.Server|https.Server} server\n * @param {Object} options\n * @api public\n */\n\nfunction setup (server, options) {\n  if (!server) server = http.createServer();\n  server.on('request', onrequest);\n  server.on('connect', onconnect);\n  return server;\n}\n\n/**\n * 13.5.1 End-to-end and Hop-by-hop Headers\n *\n * Hop-by-hop headers must be removed by the proxy before passing it on to the\n * next endpoint. Per-request basis hop-by-hop headers MUST be listed in a\n * Connection header, (section 14.10) to be introduced into HTTP/1.1 (or later).\n */\n\nvar hopByHopHeaders = [\n  'Connection',\n  'Keep-Alive',\n  'Proxy-Authenticate',\n  'Proxy-Authorization',\n  'TE',\n  'Trailers',\n  'Transfer-Encoding',\n  'Upgrade'\n];\n\n// create a case-insensitive RegExp to match \"hop by hop\" headers\nvar isHopByHop = new RegExp('^(' + hopByHopHeaders.join('|') + ')$', 'i');\n\n/**\n * Iterator function for the request/response's \"headers\".\n * Invokes `fn` for \"each\" header entry in the request.\n *\n * @api private\n */\n\nfunction eachHeader (obj, fn) {\n  if (Array.isArray(obj.rawHeaders)) {\n    // ideal scenario... >= node v0.11.x\n    // every even entry is a \"key\", every odd entry is a \"value\"\n    var key = null;\n    obj.rawHeaders.forEach(function (v) {\n      if (key === null) {\n        key = v;\n      } else {\n        fn(key, v);\n        key = null;\n      }\n    });\n  } else {\n    // otherwise we can *only* proxy the header names as lowercase'd\n    var headers = obj.headers;\n    if (!headers) return;\n    Object.keys(headers).forEach(function (key) {\n      var value = headers[key];\n      if (Array.isArray(value)) {\n        // set-cookie\n        value.forEach(function (val) {\n          fn(key, val);\n        });\n      } else {\n        fn(key, value);\n      }\n    });\n  }\n}\n\n/**\n * HTTP GET/POST/DELETE/PUT, etc. proxy requests.\n */\n\nfunction onrequest (req, res) {\n  debug.request('%s %s HTTP/%s ', req.method, req.url, req.httpVersion);\n  var server = this;\n  var socket = req.socket;\n\n  // pause the socket during authentication so no data is lost\n  socket.pause();\n\n  authenticate(server, req, function (err, auth) {\n    socket.resume();\n    if (err) {\n      // an error occured during login!\n      res.writeHead(500);\n      res.end((err.stack || err.message || err) + '\\n');\n      return;\n    }\n    if (!auth) return requestAuthorization(req, res);\n    var parsed = url.parse(req.url);\n\n    // proxy the request HTTP method\n    parsed.method = req.method;\n\n    // setup outbound proxy request HTTP headers\n    var headers = {};\n    var hasXForwardedFor = false;\n    var hasVia = false;\n    var via = '1.1 ' + hostname + ' (proxy/' + version + ')';\n\n    parsed.headers = headers;\n    eachHeader(req, function (key, value) {\n      debug.request('Request Header: \"%s: %s\"', key, value);\n      var keyLower = key.toLowerCase();\n\n      if (!hasXForwardedFor && 'x-forwarded-for' === keyLower) {\n        // append to existing \"X-Forwarded-For\" header\n        // http://en.wikipedia.org/wiki/X-Forwarded-For\n        hasXForwardedFor = true;\n        value += ', ' + socket.remoteAddress;\n        debug.proxyRequest('appending to existing \"%s\" header: \"%s\"', key, value);\n      }\n\n      if (!hasVia && 'via' === keyLower) {\n        // append to existing \"Via\" header\n        hasVia = true;\n        value += ', ' + via;\n        debug.proxyRequest('appending to existing \"%s\" header: \"%s\"', key, value);\n      }\n\n      if (isHopByHop.test(key)) {\n        debug.proxyRequest('ignoring hop-by-hop header \"%s\"', key);\n      } else {\n        var v = headers[key];\n        if (Array.isArray(v)) {\n          v.push(value);\n        } else if (null != v) {\n          headers[key] = [ v, value ];\n        } else {\n          headers[key] = value;\n        }\n      }\n    });\n\n    // add \"X-Forwarded-For\" header if it's still not here by now\n    // http://en.wikipedia.org/wiki/X-Forwarded-For\n    if (!hasXForwardedFor) {\n      headers['X-Forwarded-For'] = socket.remoteAddress;\n      debug.proxyRequest('adding new \"X-Forwarded-For\" header: \"%s\"', headers['X-Forwarded-For']);\n    }\n\n    // add \"Via\" header if still not set by now\n    if (!hasVia) {\n      headers.Via = via;\n      debug.proxyRequest('adding new \"Via\" header: \"%s\"', headers.Via);\n    }\n\n    // custom `http.Agent` support, set `server.agent`\n    var agent = server.agent;\n    if (null != agent) {\n      debug.proxyRequest('setting custom `http.Agent` option for proxy request: %s', agent);\n      parsed.agent = agent;\n      agent = null;\n    }\n\n    if (null == parsed.port) {\n      // default the port number if not specified, for >= node v0.11.6...\n      // https://github.com/joyent/node/issues/6199\n      parsed.port = 80;\n    }\n\n    if ('http:' != parsed.protocol) {\n      // only \"http://\" is supported, \"https://\" should use CONNECT method\n      res.writeHead(400);\n      res.end('Only \"http:\" protocol prefix is supported\\n');\n      return;\n    }\n\n    if (server.localAddress) {\n      parsed.localAddress = server.localAddress;\n    }\n\n    var gotResponse = false;\n    var proxyReq = http.request(parsed);\n    debug.proxyRequest('%s %s HTTP/1.1 ', proxyReq.method, proxyReq.path);\n\n    proxyReq.on('response', function (proxyRes) {\n      debug.proxyResponse('HTTP/1.1 %s', proxyRes.statusCode);\n      gotResponse = true;\n\n      var headers = {};\n      eachHeader(proxyRes, function (key, value) {\n        debug.proxyResponse('Proxy Response Header: \"%s: %s\"', key, value);\n        if (isHopByHop.test(key)) {\n          debug.response('ignoring hop-by-hop header \"%s\"', key);\n        } else {\n          var v = headers[key];\n          if (Array.isArray(v)) {\n            v.push(value);\n          } else if (null != v) {\n            headers[key] = [ v, value ];\n          } else {\n            headers[key] = value;\n          }\n        }\n      });\n\n      debug.response('HTTP/1.1 %s', proxyRes.statusCode);\n      res.writeHead(proxyRes.statusCode, headers);\n      proxyRes.pipe(res);\n      res.on('finish', onfinish);\n    });\n    proxyReq.on('error', function (err) {\n      debug.proxyResponse('proxy HTTP request \"error\" event\\n%s', err.stack || err);\n      cleanup();\n      if (gotResponse) {\n        debug.response('already sent a response, just destroying the socket...');\n        socket.destroy();\n      } else if ('ENOTFOUND' == err.code) {\n        debug.response('HTTP/1.1 404 Not Found');\n        res.writeHead(404);\n        res.end();\n      } else {\n        debug.response('HTTP/1.1 500 Internal Server Error');\n        res.writeHead(500);\n        res.end();\n      }\n    });\n\n    // if the client closes the connection prematurely,\n    // then close the upstream socket\n    function onclose () {\n      debug.request('client socket \"close\" event, aborting HTTP request to \"%s\"', req.url);\n      proxyReq.abort();\n      cleanup();\n    }\n    socket.on('close', onclose);\n\n    function onfinish () {\n      debug.response('\"finish\" event');\n      cleanup();\n    }\n\n    function cleanup () {\n      debug.response('cleanup');\n      socket.removeListener('close', onclose);\n      res.removeListener('finish', onfinish);\n    }\n\n    req.pipe(proxyReq);\n  });\n}\n\n/**\n * HTTP CONNECT proxy requests.\n */\n\nfunction onconnect (req, socket, head) {\n  debug.request('%s %s HTTP/%s ', req.method, req.url, req.httpVersion);\n  assert(!head || 0 == head.length, '\"head\" should be empty for proxy requests');\n\n  var res;\n  var target;\n  var gotResponse = false;\n\n  // define request socket event listeners\n  socket.on('close', function onclientclose () {\n    debug.request('HTTP request %s socket \"close\" event', req.url);\n  });\n\n  socket.on('end', function onclientend () {\n    debug.request('HTTP request %s socket \"end\" event', req.url);\n  });\n\n  socket.on('error', function onclienterror (err) {\n    debug.request('HTTP request %s socket \"error\" event:\\n%s', req.url, err.stack || err);\n  });\n\n  // define target socket event listeners\n  function ontargetclose () {\n    debug.proxyResponse('proxy target %s \"close\" event', req.url);\n    socket.destroy();\n  }\n\n  function ontargetend () {\n    debug.proxyResponse('proxy target %s \"end\" event', req.url);\n  }\n\n  function ontargeterror (err) {\n    debug.proxyResponse('proxy target %s \"error\" event:\\n%s', req.url, err.stack || err);\n    if (gotResponse) {\n      debug.response('already sent a response, just destroying the socket...');\n      socket.destroy();\n    } else if ('ENOTFOUND' == err.code) {\n      debug.response('HTTP/1.1 404 Not Found');\n      res.writeHead(404);\n      res.end();\n    } else {\n      debug.response('HTTP/1.1 500 Internal Server Error');\n      res.writeHead(500);\n      res.end();\n    }\n  }\n\n  function ontargetconnect () {\n    debug.proxyResponse('proxy target %s \"connect\" event', req.url);\n    debug.response('HTTP/1.1 200 Connection established');\n    gotResponse = true;\n    res.removeListener('finish', onfinish);\n\n    res.writeHead(200, 'Connection established');\n    res.flushHeaders();\n\n    // relinquish control of the `socket` from the ServerResponse instance\n    res.detachSocket(socket);\n\n    // nullify the ServerResponse object, so that it can be cleaned\n    // up before this socket proxying is completed\n    res = null;\n\n    socket.pipe(target);\n    target.pipe(socket);\n  }\n\n  // create the `res` instance for this request since Node.js\n  // doesn't provide us with one :(\n  // XXX: this is undocumented API, so it will break some day (ノಠ益ಠ)ノ彡┻━┻\n  res = new http.ServerResponse(req);\n  res.shouldKeepAlive = false;\n  res.chunkedEncoding = false;\n  res.useChunkedEncodingByDefault = false;\n  res.assignSocket(socket);\n\n  // called for the ServerResponse's \"finish\" event\n  // XXX: normally, node's \"http\" module has a \"finish\" event listener that would\n  // take care of closing the socket once the HTTP response has completed, but\n  // since we're making this ServerResponse instance manually, that event handler\n  // never gets hooked up, so we must manually close the socket...\n  function onfinish () {\n    debug.response('response \"finish\" event');\n    res.detachSocket(socket);\n    socket.end();\n  }\n  res.once('finish', onfinish);\n\n  // pause the socket during authentication so no data is lost\n  socket.pause();\n\n  authenticate(this, req, function (err, auth) {\n    socket.resume();\n    if (err) {\n      // an error occured during login!\n      res.writeHead(500);\n      res.end((err.stack || err.message || err) + '\\n');\n      return;\n    }\n    if (!auth) return requestAuthorization(req, res);\n\n    var parts = req.url.split(':');\n    var host = parts[0];\n    var port = +parts[1];\n    var opts = { host: host, port: port };\n\n    debug.proxyRequest('connecting to proxy target %j', opts);\n    target = net.connect(opts);\n    target.on('connect', ontargetconnect);\n    target.on('close', ontargetclose);\n    target.on('error', ontargeterror);\n    target.on('end', ontargetend);\n  });\n}\n\n/**\n * Checks `Proxy-Authorization` request headers. Same logic applied to CONNECT\n * requests as well as regular HTTP requests.\n *\n * @param {http.Server} server\n * @param {http.ServerRequest} req\n * @param {Function} fn callback function\n * @api private\n */\n\nfunction authenticate (server, req, fn) {\n  var hasAuthenticate = 'function' == typeof server.authenticate;\n  if (hasAuthenticate) {\n    debug.request('authenticating request \"%s %s\"', req.method, req.url);\n    server.authenticate(req, fn);\n  } else {\n    // no `server.authenticate()` function, so just allow the request\n    fn(null, true);\n  }\n}\n\n/**\n * Sends a \"407 Proxy Authentication Required\" HTTP response to the `socket`.\n *\n * @api private\n */\n\nfunction requestAuthorization (req, res) {\n  // request Basic proxy authorization\n  debug.response('requesting proxy authorization for \"%s %s\"', req.method, req.url);\n\n  // TODO: make \"realm\" and \"type\" (Basic) be configurable...\n  var realm = 'proxy';\n\n  var headers = {\n    'Proxy-Authenticate': 'Basic realm=\"' + realm + '\"'\n  };\n  res.writeHead(407, headers);\n  res.end();\n}\n"]},"metadata":{},"sourceType":"script"}